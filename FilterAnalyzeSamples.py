# ---------------------------------------------------------------------------
# NAME: FilterAnalyzeSamples.py
# Version: 2.0 (ArcGIS 10.2)
# Author: Research Planning, Inc.
#
# Usage: FilterAnalyzeSamples <input_analysis_database> <input_contaminant_layer> <value_field>
#   <value_field_units> <statistic_type> <boolean_log_transform> <contaminant_qm_documentation>
#
# Required Arguments: 
#   input_analysis_database - Name of analysis geodatabase
#   input_contaminant_layer - Name of contaminant layer imported from Query Manager
#   value_field - Value field to analyze in contaminant layer
#   value_field_units - Units of measurement of the contaminant value field
#   statistic_type - Type of statistic to perform on duplicate sample locations
#                    limited to: (Max, Mean)
#   boolean_log_transform - Boolean flag indicating if natural log of values is performed on contaminant values
#   contaminant_qm_documentation - Name and location of the autogenerated documentation text file for
#                                  the contaminant layer imported from Query Manager
#
# Description: Filter contaminant layer for duplicate samples and determine the mean or maximum value at
#              each location.  Then analyze the filtered layer for information to determine an appropriate
#              cell size for the analysis grid.
#
# Notes:  Currently the tool is designed to only be run via the ARD HEA Toolbox.
#
# Date Created: February 3, 2010
# Date V 1.0 Modified: March 2, 2010      - Filter locations where no sample was taken for contaminant (-999.99)
#                                   - Added capability to handle multiple contaminants contained in a single file
#                      March 3, 2010      - Added capability to log transform contaminant values
#                      March 8, 2010      - Consolidated ANALYSIS_TABLE and COC_INVENTORY tables
#                      March 9, 2010      - Added warning and error messages for log transformation values
#                      March 10, 2010     - Added code to log transform to multiply by 1000, floor values at 1, and then
#                                           perform log transform, Fixed issue with POINT_Y error
#                      March 16, 2010     - Moved log transform to interpolation tools
#                      October 26, 2010   - Made QM documentation optional
#                      November 30, 2010  - Added code to check for projected coordinate system and import metadata template
#                      June 1, 2011       - Edited for Arc 10.0 functionality
#                      September 15, 2012 - Changed to utilize user supplied contaminant name, Additional bug fixes
# Date V 2.0 Modified: September 17, 2013 - Converted to arcpy for V2.0 and upgraded metadata xml files
#                      February 16, 2015  - Added code to sanitize the contaminant name if it starts with spaces or numbers
#                      
# ---------------------------------------------------------------------------

class unprojected(Exception):
    pass

# Import system modules
import ARD_HEA_Tools
import sys
import string
import os
import traceback
import math
import arcpy
from arcpy import env

# Load required toolboxes...
sub_folder = "ArcToolbox/Toolboxes/"
install_dir = arcpy.GetInstallInfo("desktop")['InstallDir'].replace("\\","/")
tbx_home = os.path.join(install_dir, sub_folder)
arcpy.AddToolbox(tbx_home+"Spatial Statistics Tools.tbx")
arcpy.AddToolbox(tbx_home+"Data Management Tools.tbx")
arcpy.AddToolbox(tbx_home+"Analysis Tools.tbx")

try:
    # Report version...
    ver = ARD_HEA_Tools.version()
    arcpy.AddMessage("ARD HEA Tools Version: " + ver)
    
    # Script arguments...
    geoDB = sys.argv[1]
    COCLayer = sys.argv[2]
    COCField = sys.argv[3]
    COCName = sys.argv[4]
    COCUnits = sys.argv[5]
    STATType = sys.argv[6]
    qmDoc = sys.argv[7]
    currDir = os.path.dirname(geoDB)

    arcpy.AddMessage("COC Name: " + COCName)
    
    # Local variables...
    desc = arcpy.Describe(COCLayer)
    scriptPath = sys.path[0]
    xmlTemp = scriptPath + "\\filtered_metadata_template.xml"
    COCLayerN = COCLayer.split(os.sep)[-1]
    if desc.DataType == "FeatureLayer":
        COCLayerBase = COCLayerN
    else:
        COCLayerBase = COCLayerN.split(".")[0]
    #COCLayerBase = ARD_HEA_Tools.sanitize(COCLayerBase)
    COCLayerOut = geoDB + "\\" + ARD_HEA_Tools.sanitize(COCLayerBase) + "_Layer"
    COCStats = geoDB + "\\" + ARD_HEA_Tools.sanitize(COCName) + "_Stats"
    COCFieldStat = COCField + " " + STATType
    COCStatsLyr = ARD_HEA_Tools.sanitize(COCName) + "_Stats_Layer"
    COCFiltered = geoDB + "\\" + ARD_HEA_Tools.sanitize(COCName) + "_filtered"
    COCFilteredLyr = ARD_HEA_Tools.sanitize(COCName) + "_filtered"
    SpatRef = arcpy.Describe(COCLayer).SpatialReference
    SAField = STATType + "_" + COCField
    InventTable = geoDB + "\\COC_INVENTORY"
    fltrString = arcpy.AddFieldDelimiters(COCLayer, COCField) + " > -999.99"
    chkString1 = fltrString + " AND " + arcpy.AddFieldDelimiters(COCLayer, COCField) + " <= 0"
    chkString2 = arcpy.AddFieldDelimiters(COCLayer, COCField) + " > 0 AND " + arcpy.AddFieldDelimiters(COCLayer, COCField) + " < 1"

    # Check for projected coordinate system...
    project = desc.SpatialReference.Name
    units = desc.SpatialReference.LinearUnitName.upper()
    if units == "":
        raise unprojected
    
    # Set the geoprocessing environment
    env.overwriteOutput = 1

    # Process: Make Feature Layer...
    arcpy.MakeFeatureLayer_management(COCLayer, "templyr", fltrString, "", "")
    arcpy.CopyFeatures_management("templyr", COCLayerOut, "", "")
    arcpy.Delete_management("templyr")

    # Process: Add XY Coordinates
    arcpy.AddXY_management(COCLayerOut)

    # Process: Summary Statistics...
    arcpy.AddMessage("Filtering Samples...")  
    arcpy.Statistics_analysis(COCLayerOut, COCStats, COCFieldStat, "POINT_X;POINT_Y")
    arcpy.Delete_management(COCLayerOut)

    # Process: Make XY Event Layer...
    arcpy.MakeXYEventLayer_management(COCStats, "POINT_X", "POINT_Y", COCStatsLyr, SpatRef)
    arcpy.CopyFeatures_management(COCStatsLyr, COCFiltered)

    # Process: Capture geoprocessing history...
    history = ARD_HEA_Tools.get_process_history(currDir, COCStats)

    # Cleanup intermediate files
    # arcpy.Delete_management(COCStats)

    #Import metadata template...
    arcpy.AddMessage("Updating metadata...")
    arcpy.ImportMetadata_conversion(xmlTemp, "FROM_FGDC", COCFiltered)
    # arcpy.MetadataImporter_conversion(xmlTemp, COCFiltered)

    # Process: Average Nearest Neighbor...
    arcpy.AddMessage("\nDetermining Average Nearest Neighbor stats...")
    NNOutput = arcpy.AverageNearestNeighbor_stats(COCFiltered, "#", "#", "#")
    arcpy.AddMessage("The nearest neighbor index is: " + NNOutput.getOutput(0))
    arcpy.AddMessage("The z-score of the nearest neighbor index is: " + NNOutput.getOutput(1))
    arcpy.AddMessage("The p-value of the nearest neighbor index is: " + NNOutput.getOutput(2))

    # Process: Spatial Autocorrelation (Morans I)...
    arcpy.AddMessage("\nDetermining Spatial Autocorrelation stats...")
    SAOutput = arcpy.SpatialAutocorrelation_stats(COCFiltered, SAField)
    arcpy.AddMessage("The spatial autocorrelation index is: " + SAOutput.getOutput(0))
    arcpy.AddMessage("The z-score of the spatial autocorrelation is: " + SAOutput.getOutput(1))
    arcpy.AddMessage("The p-value of the spatial autocorrelation is: " + SAOutput.getOutput(2))

    # Process: Calculate Distance Band from Neighbor Count...
    arcpy.AddMessage("\nDetermining Distance Band from Neighbor...")
    CDBOutput = arcpy.CalculateDistanceBand_stats(COCFiltered, "1", "#")
    arcpy.AddMessage("The minimum distance band is: " + CDBOutput.getOutput(0))
    arcpy.AddMessage("The average distance band is: " + CDBOutput.getOutput(1))
    arcpy.AddMessage("The maximum distance band is: " + CDBOutput.getOutput(2) + "\n")

    # Process: Capture geoprocessing history...
    history = history + ARD_HEA_Tools.get_process_history(currDir, COCFiltered)

    #Read in query manager document
    if arcpy.Exists(qmDoc):
        f = open(qmDoc, "r")
        qmText = f.read()
        f.close()
    else:
        qmText = None
    
    #Process: Update contaminant inventory table...
    rows = arcpy.UpdateCursor(InventTable, "[COC_NAME] = '" + COCName + "'")
    row = rows.next()
    if row:
        while row:
            arcpy.AddMessage("Updating COC Name: " + COCName)
            row.COC_NAME = COCName
            row.COC_UNITS = COCUnits
            if qmText is not None:
                row.COC_QMDOC = qmText
            row.COC_XML = history
            row.INPUT_LAYER_NAME = COCLayerBase
            row.FILTER_LAYER_NAME = COCFilteredLyr
            row.STAT_TYPE = STATType
            row.MIN_DIST = CDBOutput.getOutput(0)
            row.AVG_DIST = CDBOutput.getOutput(1)
            row.MAX_DIST = CDBOutput.getOutput(2)
            row.NNRATIO = NNOutput.getOutput(0)
            row.NNZSCORE = NNOutput.getOutput(1)
            row.NNPVALUE = NNOutput.getOutput(2)
            row.SAINDEX = SAOutput.getOutput(0)
            row.SAZSCORE = SAOutput.getOutput(1)
            row.SAPVALUE = SAOutput.getOutput(2)
            row.LOG_TRANSFORM = ""
            row.INTERP_LAYER_NAME = ""
            row.INTERP_TYPE = ""
            rows.updateRow(row)
            row = rows.next()
    else:
        del row
        del rows
        rows = arcpy.InsertCursor(InventTable)
        row = rows.newRow()
        row.COC_NAME = COCName
        arcpy.AddMessage("Inserting COC Name: " + COCName)
        row.COC_UNITS = COCUnits
        if qmText is not None:
            row.COC_QMDOC = qmText
        row.COC_XML = history
        row.INPUT_LAYER_NAME = COCLayerBase
        row.FILTER_LAYER_NAME = COCFilteredLyr
        row.STAT_TYPE = STATType
        row.MIN_DIST = CDBOutput.getOutput(0)
        row.AVG_DIST = CDBOutput.getOutput(1)
        row.MAX_DIST = CDBOutput.getOutput(2)
        row.NNRATIO = NNOutput.getOutput(0)
        row.NNZSCORE = NNOutput.getOutput(1)
        row.NNPVALUE = NNOutput.getOutput(2)
        row.SAINDEX = SAOutput.getOutput(0)
        row.SAZSCORE = SAOutput.getOutput(1)
        row.SAPVALUE = SAOutput.getOutput(2)
        row.LOG_TRANSFORM = ""
        row.INTERP_LAYER_NAME = ""
        row.INTERP_TYPE = ""
        rows.insertRow(row)
    del row
    del rows
    
    # Process: Make feature layer
    arcpy.MakeFeatureLayer_management(COCFiltered, COCFilteredLyr, "", "", "")

    # Set ouptut geoprocessing history
    ARD_HEA_Tools.set_process_history (currDir, COCFiltered, history)

except unprojected:
    arcpy.AddError("\n*** ERROR ***\nCannot import COC sample data with an unprojected coordinate system.\n")
    print "\n*** ERROR ***\nCannot import COC sample data with an with an unprojected coordinate system.\n"

except arcpy.ExecuteError:
    # Get the tool error messages
    msgs = arcpy.GetMessage(0)
    msgs += arcpy.GetMessages(2)

    # Return tool error messages for use with a script tool
    arcpy.AddError(msgs)

    # Print tool error messages for use in Python/PythonWin
    print msgs
    
except:
    # Get the traceback object
    #
    tb = sys.exc_info()[2]
    tbinfo = traceback.format_tb(tb)[0]

    # Concatenate information together concerning the error into a message string
    #
    pymsg = "PYTHON ERRORS:\nTraceback info:\n" + tbinfo + "\nError Info:\n" + str(sys.exc_info()[1])
    msgs = "ArcPy ERRORS:\n" + arcpy.GetMessages(2) + "\n"

    # Return python error messages for use in script tool or Python Window
    #
    arcpy.AddError(pymsg)
    arcpy.AddError(msgs)

    # Print Python error messages for use in Python / Python Window
    #
    print pymsg + "\n"
    print msgs

